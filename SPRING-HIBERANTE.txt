->DataSource - how we are connecting to a database.
             - In order to connect java application with the databaase.It needs datasource.
             - Datasource internally manages the connections.

->Add hibernate-core dependency to the pom.

1)hibernate.cfg.xml:
<?xml..................>
<DOCTYPEf ..............>
<hibernate-configuration>
  <session-factory>
    <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate-morning</property>
    <property name="hibernate.connection.username">root</property>
    <property name="hibernate.connection.password">vivek</property>
    <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
  </session-factory>
</hibernate-configuration>

->Inorder to work with hiberate ,we have to do the following :
  ->First we need session object to perform database operations with hibernate.
  ->Inorder to initialize the session object,we need session factory.
  ->To create a sessionFactory we need some configurations regarding the database.

2)code:
p s v m(s[] srgs)
{
    //create configuration
    Configuration con=new Configuration();
    con.configure("hibernate.connection.cfg.xml");
    con.addAnnotatedClass(Song.class);

    //create sessionFactory
    SessionFactory sf=con.buildSessionFactory();

    //initialize the session object
    Session s=sf.openSession();

    Song s1=new Song();
    s1.setId(1);
    s1.setSongName("rim zim");
    s1.setArtist("vivek");
    
    session.beginTransaction();
    session.save(s1);
    session.getTransaction().commit();
}

3)entity: This entity represents table in a database.

@Entity -------------->javax.persistence.Entity
public class Song{

    @Id  --------------->javax.persistence.Id
    @Column(name="songId")
    private int id;
    
    @Column(name="songName")
    private String songName;

    @Column(name="singer")
    private String artist;

    setters and getters....
}

->If we configure the  following property in hibernate.cfg,xml,Then it will enable logging of generate sql to the console.
   
   [ <Property name="hibernate.show_sql"> true</property> ]

->we no need to give "hibernate.cfg.xml" as a parameter to configure.It will always look for that file ,if don't pass as a parameter.
  But,If we name it with different name we should pass the parameter.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
session.get(Song.class,2) -> will get the record based on song id with value '2'
session.load(Song.class,2) ->It will also do the same.
->Inorder to update and delete any record,we have to load that record first.
ex:
   1)Song s=session.get(Song.class,1);
     s.setName("....");
     session.update(s);
   2)Song s=session.get(Song.class,1);
     session.beginTransaction();
     session.delete(s);
     session.getTransaction().commit();

->As SessionFactory object is heavy weight obj,we have to create only one SessionFactory in our application.
 So,we can make a Singleton util class that is having a method which returns only one SessionFactory object everytime.

public class HibernateUtils
{
      private static SessionFactory sf=null;
      public static SessionFactory getSessionFactory()
      {
        if(sf==null)
        {
            Configuration con=new Configuration();
            con.configure();
            con.addAnnotatedClass(Song.class);

            sf=con.buildSessionFactory();
        }
        return sf;
      }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
->@GeneratedValue(strategy=GenerationType.IDENTITY) which indicates that db is responsible to generate primary key and map that key to the id of an entity.
ex:
  session.beginTransaction();    
  session.save(obj);                   ---->(1)
  session.getTransaction().commit();   ---->(2)
       ->after executing the line (1) data will not be saved into actual db.It will be persisted after commiting only it will be saved into the db.
       ->While executing the line (1) itself the hibernate will generate the query but the data will not be saved into db.

->In Hibernate, an object can be in one of three states: transient, persistent, or detached. These states define the lifecycle of a Hibernate-managed entity 
and dictate how Hibernate manages the object's lifecycle with respect to the database. Here's a detailed explanation of each state:
1)Transient State: An object is in the transient state when it is created but not yet associated with a Hibernate session. 
                   It does not have a corresponding record in the database, and Hibernate is not aware of its existence.
->Creation: The object is created using the new operator.
->No Database Representation: There is no corresponding row in the database.
->Not Managed by Hibernate: Hibernate does not track changes to this object.

 ex:
        // Create a transient object
        User user = new User();
        user.setName("John Doe");
        user.setEmail("john.doe@example.com");
    
2)Persistent State:An object is in the persistent state when it is associated with an active Hibernate session. 
                  Hibernate tracks changes to the object and synchronizes these changes with the database.

->Managed by Hibernate: The object is associated with a session, and Hibernate tracks its state.
->Database Representation: There is a corresponding row in the database.
->Automatic Synchronization: Changes to the object's properties are automatically synchronized with the database.

ex:
                Session session = sessionFactory.openSession();
                session.beginTransaction();

                // The object is now in the persistent state
                session.save(user);  // user becomes persistent

                // Changes to the object are automatically saved to the database
                user.setEmail("new.email@example.com");

                session.getTransaction().commit();
                session.close();

3) Detached State:An object is in the detached state when it was once associated with a Hibernate session but is no longer associated with any session.
                   The object is no longer being tracked by Hibernate.

->Previously Persistent: The object was once in the persistent state but the session has been closed or cleared.
->No Longer Managed: Hibernate is no longer tracking changes to the object.
->Manual Synchronization: Changes to the object's properties are not automatically synchronized with the database.

 ex:
   
            // Assume the session is closed, user is now detached
            Session newSession = sessionFactory.openSession();
            newSession.beginTransaction();

            // Attach the detached object to a new session to make it persistent again
            newSession.update(user);
            user.setName("Updated Name");

            newSession.getTransaction().commit();
            newSession.close();

->Summary:
1)Transient State: The object is not associated with a session and not represented in the database.
2)Persistent State: The object is associated with an active session and is represented in the database. Changes to the object are automatically synchronized with the database.
3)Detached State: The object was previously persistent but is no longer associated with any session. Changes to the object are not synchronized with the database unless explicitly reattached to a session.



