JSON->JAVA SCRIPT OBJECT NOTATION
   ->json is lang independent.Ex:take react or any front tech and spring or any backend tech,They can communicate easily with the help of json.
      (machine to machine communication)
   ->can be used with any programming language.
   ->we can store/exchange data.
  ex:
      {
	    "name""vivek",                                      
		"address":"VZG",
		"mobile"93923,                        
		"isPanAvailable":true,
		"langKnown":["python","java"]
	  }
	
----------------------------------------------------------------------------------
  EX:
     {
	 "name":"vivek",
	 "id":1
	 }
	   |
	   |  (DATA BINDING,Reading data from json and binding data to the java class)
	   |
	class Student
	{
	  String name;
	  int id;
	}

      (JSON->JAVA):
->In order to bind the data from json to java object,we need jackson-databind maven dependency.
  EX:consider a json file 'student.json' with some specific file location 'x'.If we want to read the values of json and set the values to 
      corresponding Student object values.we can do it in the following way.
	  
	  p s v m(s[] args)
	  {
	    ObjectMapper obj=new ObjectMapper();
		Student stu=obj.readValue(new File(x),Student.class);
      }
	  
	 ->ObjectMapper is from 'com.fasterxml.jackson.databind' pkg.
	* ->Instead of specificying the path of json,we can directly place a json object as first parameter of readValue function.It will work as the same.

      (JAVA->JSON):
->If we want to create a json object using the java object ,we have to do in the following way.
  
   p s v m(s[] args)
   {
     ObjectMapper obj=new ObjectMapper();
	 
	 Student st=new Student();
	 st.setName("vivek");
	 st.setId(12);
	 
	 obj.writeValue(new File(x),st);
	}

*->If we have the more properties in the json  than in Java class,we get the exception as "unrecognized properties".
    |
	In this case we can ignore the unknown properties by specifying in the following way:
	 
	@JsonIgnoreProperties(ignoreUnknown=true)
	public class Student
	{
	}
	                       (OR)
	If we want to ignore some specific properties ,then we can specify in the following way:(In the below example,name value of json will not set to field value,so now the value of java field name
	   will be null as it is the default value of string in java)
	
	@JsonIgnoreProperties(value="name")    -> we can specify the multiple properties as "value={"name","id"}"
	public class Student
	{
	}

*->If our pojo have a field named "isActive" then idle will generate getter and setter in the following way:
   |
   getter method-> isActive() 
   setter method-> setActive()
   For the value to be bind to the field of java pojo ,we have to make the change in the field name as "getIsActive" other wise the value will not be bind.
                 OR
   we can specify using annotation in the following way.
      @JsonProperty("isActive")  ->[recommended to use]
	  private boolean isActive;
	  
->If we have the field name as "FullName" in json and out java class as field name as "name"
   we can specify as the following to set the value of fullName to the name:
       @JsonProperty("fullName")
	   private String name;

->If we have list of json objects in the json file ,we can set those in the following way:

  ObjectMapper obj=new ObjectMapper();
  Student[] st=obj.readValue(new File(x),Student[].class)
---------------------------------------------------------------------------------------------------------------------
->@RestController -> A convenience annotation that is itself annotated with @Controller and @ResponseBody.

-> if we dont use @ResponseBody at the class level or method level ,It will return a page with the name with return string.
   but if we use @ResponseBody then it ill return a string.
   --------------------------------------------------------------------------------------------------------------------
   spring rest:
	    ->add jackson-databind dependecy in the pom and add @EnableWebMvc annotation at the class level in config file to convert json to java obj and java obj to json.
		->add jackson-datasource-xml in the pom to produce the output in xml format.
		->In order to get data in required format we can add the Accept(key) in request header in postman with value application/json (or) application/xml.
		->To negotiate the content we have to add the key produces with value as MediaType.Application_Json_Value or MediaType.Application_XML_value.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
uri-> ..../{id}
       ->@PathVariable("id") int id;
	   -> if name of the path variable and parameter are both same then there is no need to specify name beside @pathvariable.
uri->....?id=1&name=vivek&country=india
        ->@RequestParam("id) int id,@RequestParam("name") String name,@RequestParam("country") String country;
If a controller having two apis with the uri's .../{id} & ...../{name} then there is an ambiguity so ,we can resolve this by using params.i.e..
    @GetMapping(value="/student/{id}",params="xyz")
	@GetMapping(value="/student/{name}",params="yyy")
->In order to map the json object values with the java object,we have to use the @RequestBody annotation.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
->if our api wants to consume the data in the form of json only,we can specify using the consumes=MediaType.APPLICATION_JSON_VALUE and similarly for xml too.
      we have to add "content-Type" as application/json or application/xml in request headers while using "consumes".
	  similarly "Accept" while using "produces".
->while giving response from our api,along with return type we have to give a proper http status code.
->For that we have to return "ResponseEntity<ReturnType>" .while returning we have to use the following line
     "ResponseEntity.status(HttpStatus.CREATED).body(......)"
------------------------------------------------------------------------------------------------------------------------------------------------------------
Handling Exceptions:
 
1)Create a pkg exception and write excpetion classes in that as following.
  
  public class StudentNotFoundException extends Exceptions
  {
	public StudentNotFoundException(String msg)
	{
		super(msg);
	}
  }

2)write a handler method for that exception
  
  @ExceptionHandler
  public ResponseEntity<ErrorResponse> handleExcp(StudentNotFoundException snf)
  {
	ErrorResponse err=new ErrorResponse();
	err.set..();
	..
	return ResponseEntity.status(HttpStatus.NOT_FOUND).body(err);
  }

->For every exception that we are throwing in our business logic ,we have to handle that exception.
->Instead of writing the handling code in one controller for that controller class,we have to write the code at global level.so,that it will be handled for all the controllers.
ex:
  
  @ControllerAdvice
  class GlobalExceptionHandler
  {
	@ExceptionHandler
	........
  }
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  
  



	
	




	